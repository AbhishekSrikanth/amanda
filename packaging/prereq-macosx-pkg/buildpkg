#! /bin/bash

# This script builds a number of prerequisite packages required by Amanda
# but not provided directly by the operating system.  These packages are
# all installed with a prefix of ($PREFIX).  This script should be run
# from the root of the distribution directory.
#
# This script *must* be run as root, because each of these applications
# depends on the others being installed in place --
# 'make DESTDIR=/tmp/foo install' won't work in this case.

##
## config parameters
##

# The install prefix
PREFIX=/opt/zmanda/prereq

# the packages we want to build, in order.  If this list changes, update the
# corresponding list in Readme.rtf.
PACKAGES="libffi libiconv gettext pkg_config perl Switch JSON Encode_Locale glib"
libiconv_VERSION=1.14
gettext_VERSION=0.19
pkg_config_VERSION=0.28
perl_VERSION=5.16.3
glib_VERSION=2.29.4
libffi_VERSION=3.1
Switch_VERSION=2.17 #Switch is needed if perl verions greater than 5.10
JSON_VERSION=2.90
Encode_Locale_VERSION=1.05
# Gnu download server base url
GNU_HTTP="http://ftp.gnu.org/pub/gnu"
libiconv_URL="${GNU_HTTP}/libiconv"
gettext_URL="${GNU_HTTP}/gettext"
pkg_config_URL="http://pkgconfig.freedesktop.org/releases"
perl_URL="http://www.cpan.org/src"
glib_URL="http://ftp.gnome.org/pub/gnome/sources/glib/2.29"
libffi_URL="ftp://sourceware.org/pub/libffi"
Switch_URL="http://www.cpan.org/authors/id/C/CH/CHORNY"
JSON_URL="http://cpan.metacpan.org/authors/id/M/MA/MAKAMAKA"
Encode_Locale_URL="http://search.cpan.org/CPAN/authors/id/G/GA/GAAS"
# directory containing the tarballs -- we don't download these for you.
TARBALL_DIR=packaging/prereq-macosx-pkg

# Location of all of the packaging pieces-parts
PKG_PARTS_DIR=packaging/prereq-macosx-pkg

# temporary directory
BUILD_TMP=/private/tmp/prereq-macosx-pkg

# package info; bump this version number on each new release
PKGNAME="amanda_enterprise-prerequisites"
VERSIONMAJ="2"
VERSIONMIN="0"
VERSION="$VERSIONMAJ.$VERSIONMIN"

# get the operating system version
# NOTE: for the moment, the same package works on all supported versions
# of Mac OS X.
#OSVERS=`uname -r | sed 's/[0-9]*\.\([0-9]*\)\.[0-9]*/\1/'`
#OSVERS=$((OSVERS-7))
#OSVERS="10.$OSVERS"

##
## package build scripts
##
## Each package uses check_tarball, to check whether everything is in place
## and possible get_tarball if not. Then we execute build_PKG, which builds
## and installs the package into $PREFIX.
##

get_tarball() {
    # Mac's ftp can fetch things for us using http or ftp.
    # $1: a full url.  check_tarball has enough info to format a reasonable guess.
    ftp -o ${TARBALL_DIR}/`basename ${1}` ${1}
    if ! test $? = 0; then
	errmsg "Could not download ${1}."
	return 1
    fi
}

check_tarball() {
    # $1: package from PACKAGES
    # $2: corresponding _VERSION variable.
    # $3: corresponding _URL variable.
    # We use regex substitutuion on $1 because "-" is prohibited in variable
    # names, but pkg-config contains one.
    # We use indirection to get the values of variable names passed as $2 and $3
    local tarball="${1/_/-}-${!2}.tar.gz"
    local url="${!3}/${tarball}"
    if ! test -f "${TARBALL_DIR}/${tarball}"; then
	get_tarball "${url}"
	if ! test -f "${TARBALL_DIR}/${tarball}"; then
	    errmsg "${TARBALL_DIR}/${tarball} not found and download failed. please download from ${!3}"
	    return 1
	fi
    fi
}

## libiconv

build_libiconv() {
    local tarball="${TARBALL_DIR}/libiconv-${libiconv_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/libiconv"
    local -a myconf

    notemsg "Building libiconv"

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # configure it
    myconf=("${myconf[@]}" --prefix="${PREFIX}")
    cd "${workdir}/libiconv-${libiconv_VERSION}" || return 1
    notemsg "Configuring with ${myconf[@]}"
    ./configure --quiet "${myconf[@]}" || return 1

    # build it
    make || return 1

    # and install it
    make install || return 1

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp COPYING "${PREFIX}/Licenses/libiconv.COPYING"
}

## libffi

build_libffi() {
    local tarball="${TARBALL_DIR}/libffi-${libffi_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/libffi"
    local -a myconf

    notemsg "Building libffi"

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # configure it
    myconf=("${myconf[@]}" --prefix="${PREFIX}")
    cd "${workdir}/libffi-${libffi_VERSION}" || return 1
    notemsg "Configuring with ${myconf[@]}"
    ./configure --quiet "${myconf[@]}" || return 1

    # build it
    make || return 1

    # and install it
    make install || return 1

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp LICENSE "${PREFIX}/Licenses/libffi.LICENSE"
}

## Switch

build_Switch() {
    local tarball="${TARBALL_DIR}/Switch-${Switch_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/Switch"

    notemsg "Building Switch"
    depend_on perl || return 1

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # use uewly compiled perl to generate makefile
    cd "${workdir}/Switch-${Switch_VERSION}" || return 1
    ${PREFIX}/bin/perl Makefile.PL || return 1

    # build it
    make || return 1

    # and install it
    make install || return 1

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp README "${PREFIX}/Licenses/Switch.README"
}

## JSON

build_JSON() {
    local tarball="${TARBALL_DIR}/JSON-${JSON_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/JSON"

    notemsg "Building JSON"
    depend_on perl || return 1

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # use uewly compiled perl to generate makefile
    cd "${workdir}/JSON-${JSON_VERSION}" || return 1
    ${PREFIX}/bin/perl Makefile.PL || return 1

    # build it
    make || return 1

    # and install it
    make install || return 1

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp README "${PREFIX}/Licenses/JSON.README"
}

## Encode_Locale

build_Encode_Locale() {
    local tarball="${TARBALL_DIR}/Encode-Locale-${Encode_Locale_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/Encode-Locale"

    notemsg "Building Encode_Locale"
    depend_on perl || return 1

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # use uewly compiled perl to generate makefile
    cd "${workdir}/Encode-Locale-${Encode_Locale_VERSION}" || return 1
    ${PREFIX}/bin/perl Makefile.PL || return 1

    # build it
    make || return 1

    # and install it
    make install || return 1

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp README "${PREFIX}/Licenses/Encode_Locale.README"
}

## gettext

build_gettext() {
    local tarball="${TARBALL_DIR}/gettext-${gettext_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/gettext"
    local -a myconf

    notemsg "Building gettext"
    depend_on libiconv || return 1

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # configure it
    myconf=()
    myconf=("${myconf[@]}" --prefix="${PREFIX}")
    myconf=("${myconf[@]}" --with-libiconv-prefix="${PREFIX}")
    myconf=("${myconf[@]}" --with-libintl-prefix="${PREFIX}")
    myconf=("${myconf[@]}" --with-glib-2.0-prefix="${PREFIX}")
    cd "${workdir}/gettext-${gettext_VERSION}" || return 1
    notemsg "Configuring with ${myconf[@]}"
    ./configure --quiet "${myconf[@]}" || return 1

    # build it
    make || return 1

    # and install it
    make install || return 1

    # remove some unnecessary stuff
    rm -rf "${PREFIX}/share/doc/gettext/examples"

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp COPYING "${PREFIX}/Licenses/gettext.COPYING"
}

## glib

build_glib() {
    local tarball="${TARBALL_DIR}/glib-${glib_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/glib"
    local -a myconf

    notemsg "Building glib"
    depend_on perl gettext pkg_config || return 1

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # configure it
    myconf=()
    myconf=("${myconf[@]}" --prefix="${PREFIX}")
    myconf=("${myconf[@]}" LDFLAGS="-L${PREFIX}/lib")
    myconf=("${myconf[@]}" CFLAGS="-I${PREFIX}/include")
    myconf=("${myconf[@]}" PKG_CONFIG="${PREFIX}/bin/pkg-config")
    myconf=("${myconf[@]}" --with-libiconv=gnu)
    cd "${workdir}/glib-${glib_VERSION}" || return 1
    notemsg "Configuring with ${myconf[@]}"
    ./configure --quiet "${myconf[@]}" || return 1

    # build it
    make || return 1

    # and install it
    make install || return 1

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp COPYING "${PREFIX}/Licenses/glib.COPYING"
}

## pkg_config

build_pkg_config() {
    local tarball="${TARBALL_DIR}/pkg-config-${pkg_config_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/pkg-config"
    local -a myconf

    notemsg "Building pkg-config"

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # configure it
    myconf=()
    myconf=("${myconf[@]}" --prefix="${PREFIX}")
    myconf=("${myconf[@]}" --with-internal-glib)
    cd "${workdir}/pkg-config-${pkg_config_VERSION}" || return 1
    notemsg "Configuring with ${myconf[@]}"
    ./configure --quiet "${myconf[@]}" || return 1

    # build it
    make || return 1

    # install it
    make install || return 1

    # clean up
    rm -rf "${PREFIX}/share/gtk-doc"

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp COPYING "${PREFIX}/Licenses/pkg-config.COPYING"
}

## perl

build_perl() {
    local tarball="${TARBALL_DIR}/perl-${perl_VERSION}.tar.gz"
    local workdir="${BUILD_TMP}/perl"
    local -a myconf

    notemsg "Building perl"

    # unpack the source
    mkdir -p "${workdir}" || return 1
    tar --directory "${workdir}" -zxf "${tarball}" || return 1

    # Configure it.  We try to remove as many references to /usr/local and /opt/local
    # as possible (they are added by Perl's darwin hints)
    local cflags="-fno-common -Dperl_DARWIN -no-cpp-precomp -fno-strict-aliasing -pipe -Wdeclaration-after-statement -I${PREFIX}/include"
    myconf=()
    myconf=("${myconf[@]}" -desO) # use defaults, override them where necessary
    myconf=("${myconf[@]}" -Dperladmin="support@zmanda.com")
    myconf=("${myconf[@]}" -Dcc="/usr/bin/gcc")
    myconf=("${myconf[@]}" -Dprefix="${PREFIX}")
    myconf=("${myconf[@]}" -Dvendorprefix="${PREFIX}")
    myconf=("${myconf[@]}" -Dsiteprefix="${PREFIX}")
    myconf=("${myconf[@]}" -Dlddlflags=" -bundle -undefined dynamic_lookup")
    myconf=("${myconf[@]}" -Ulocincpath=)
    myconf=("${myconf[@]}" -Uloclibpath=)
    myconf=("${myconf[@]}" -Duse64bitint) # (use64bitall is not available)
    cd "${workdir}/perl-${perl_VERSION}" || return 1
    notemsg "Configuring with ${myconf[@]}"
    sleep 2
    ./configure "${myconf[@]}" || return 1

    # build it
    make || return 1

    # install it
    make install || return 1

    # copy license file in
    mkdir -p "${PREFIX}/Licenses"
    cp Copying "${PREFIX}/Licenses/pkg-config.Copying"
    cp Artistic "${PREFIX}/Licenses/pkg-config.Artistic"
}

##
## Packaging
##
## Lifted from packaging/macosx-pkg/buildpkg
##

make_pkg() {
    local BUILDTYPE="${1}"

    # figure out the name of the package, making sure $PKG is an
    # absolute path
    local PKGNAMEVERS="${PKGNAME}-${VERSION}"
    local PKG="/tmp/${PKGNAMEVERS}.pkg"
    local ARCH="x86_64"
    local DMG="/tmp/${PKGNAMEVERS}.${ARCH}.dmg"

    echo "Assembling ${PKG}"

    # .pkg files aren't files at all -- they're directories.  Let's
    # start fresh.
    rm -rf "${PKG}" || exit 1
    mkdir -p "${PKG}" || exit 1
    mkdir "${PKG}/Contents" || exit 1
    mkdir "${PKG}/Contents/Resources" || exit 1
    mkdir "${PKG}/Contents/Resources/English.lproj" || exit 1

    # gather some info about the package
    INSTSIZE=`du -ks "${PREFIX}"|sed 's!\([0-9]*\).*!\1!'`
    DESCRIPTION="Prerequisite libraries for Amanda Enterprise Edition"

    # some shorthand macros
    local RSRCDIR="${PKG}/Contents/Resources"
    local LPROJDIR="${RSRCDIR}/English.lproj"

    # Add a version number file
    echo "PREREQ_VERSIONMIN=$VERSIONMIN" > "${PREFIX}/VERSION"
    echo "PREREQ_VERSIONMAJ=$VERSIONMAJ" >> "${PREFIX}/VERSION"

    # Put all of the files from the install in the appropriate place
    make_pax "${PKG}/Contents/Archive.pax.gz" || exit 1
    make_bom "${PKG}/Contents/Archive.bom" || exit 1

    # Packages expect symlinks from the Resource directory.  Weird.
    ( cd "${RSRCDIR}" || exit 1
      ln -s "../Archive.pax.gz" "${PKGNAMEVERS}.pax.gz" || exit 1
      ln -s "../Archive.bom" "${PKGNAMEVERS}.bom" || exit 1
    ) || exit 1

    # Add the "Licenses" folder
    cp -r "${PREFIX}/Licenses" "${PKG}/Licenses" || exit 1

    # Write up some informational files
    make_Info_plist "${PKG}/Contents/Info.plist" "com.zmanda.${PKGNAME}" "${PREFIX}" "${INSTSIZE}" \
        || exit 1
    make_PkgInfo "${PKG}/Contents/PkgInfo" \
        || exit 1
    make_BundleVersions "${RSRCDIR}/BundleVersions.plist" \
        || exit 1
    make_package_version "${RSRCDIR}/package_version" \
        || exit 1
    make_package_sizes "${RSRCDIR}/${PKGNAMEVERS}.sizes" "${INSTSIZE}" \
        || exit 1
    make_Description_plist "${LPROJDIR}/Description.plist" "${DESCRIPTION}" \
        || exit 1
    make_package_info "${LPROJDIR}/${PKGNAMEVERS}.info" "${DESCRIPTION}" "${PREFIX}" \
        || exit 1

    # Copy the appropriate Welcome, Readme and License files to English.lproj
    cp "${PKG_PARTS_DIR}/"*.rtf "${LPROJDIR}" || exit 1

    echo "Building .dmg file"
    hdiutil create -srcfolder "${PKG}" "${DMG}" || exit 1
    notemsg "Complete. Package and disk image are in /tmp:"
    ls -ald "${PKG}" "${DMG}"
}

# make_pax BASEDIR PAXGZ
make_pax() {
    local PAXGZ="${1}"

    (
        cd "${PREFIX}" || exit 1
        pax -x cpio -z -w -f "${PAXGZ}" . || exit 1
    ) || exit 1
}

# make_bom ROOTDIR BOMFILE
# make the Archive.bom file, containing *all* files, both from the overlay and
# from the pax archive.  This is a "simple" bom file, without any permissions
# information in it (since the permissions and ownership on the files in ROOTDIR
# are not correct for the final installation)
make_bom() {
    local BOMFILE="${1}"

    (
        cd "${PREFIX}" || exit 1
        mkbom -s . "${BOMFILE}" || exit 1
    ) || exit 1
}

# make_Info_plist INFOPLIST VERSION BUNDLEIDENTIFIER PREFIX INSTSIZE
make_Info_plist() {
    local INFOFILE="${1}"
    local BUNDLEID="${2}"
    local PREFIX="${3}"
    local INSTSIZE="${4}"

    # calculate a short version that's only #.#.#
    cat <<EOF >"${INFOFILE}"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleGetInfoString</key>
	<string>${VERSION}</string>

	<key>CFBundleIdentifier</key>
	<string>${BUNDLEID}</string>

	<key>CFBundleShortVersionString</key>
	<string>${VERSION}</string>

	<key>IFMajorVersion</key>
	<integer>${VERSIONMAJ}</integer>

	<key>IFMinorVersion</key>
	<integer>${VERSIONMIN}</integer>

	<key>IFPkgFlagAllowBackRev</key>
	<false/>

	<key>IFPkgFlagAuthorizationAction</key>
	<string>RootAuthorization</string>

	<key>IFPkgFlagBackgroundAlignment</key>
	<string>topleft</string>

	<key>IFPkgFlagBackgroundScaling</key>
	<string>none</string>

	<key>IFPkgFlagDefaultLocation</key>
	<string>${PREFIX}</string>

	<key>IFPkgFlagFollowLinks</key>
	<true/>

	<key>IFPkgFlagInstallFat</key>
	<false/>

	<key>IFPkgFlagInstalledSize</key>
	<integer>${INSTSIZE}</integer>

	<key>IFPkgFlagIsRequired</key>
	<false/>

	<key>IFPkgFlagOverwritePermissions</key>
	<false/>

	<key>IFPkgFlagRelocatable</key>
	<false/>

	<key>IFPkgFlagRestartAction</key>
	<string>NoRestart</string>

	<key>IFPkgFlagRootVolumeOnly</key>
	<false/>

	<key>IFPkgFlagUpdateInstalledLanguages</key>
	<false/>

	<key>IFPkgFormatVersion</key>
	<real>0.10000000149011612</real>
</dict>
</plist>
EOF
}

# make_PkgInfo PKGINFO
# this one's easy.
make_PkgInfo() {
    echo 'pmkrpkg1' >"${1}"
}

# make_BundleVersions BUNDLEVERSIONS_PLIST
# this one's easy too.
make_BundleVersions() {
    cat <<EOF >"${1}"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>
EOF
}

# make_package_version PACKAGE_VERSION VERSION
# Write package_version
make_package_version() {
    local PACKAGE_VERSION="${1}"

    cat <<EOF >"${PACKAGE_VERSION}"
major: ${VERSIONMAJ}
minor: ${VERSIONMIN}
EOF
}

# make_package_sizes PACKAGE_SIZES
make_package_sizes() {
    local PACKAGE_SIZES="${1}"

    # note that NumFiles and CompressedSize are 0 in a PackageMaker-created
    # .sizes file, so we leave them zero here.
    cat <<EOF >"${PACKAGE_SIZES}"
NumFiles 0
InstalledSize ${INSTSIZE}
CompressedSize 0
EOF
}

# make_Description_plist DESCRIPTION_PLIST DESCRIPTION
# Set up Description.plist
make_Description_plist() {
    local DESCRIPTION_PLIST="${1}"
    local DESCRIPTION="${2}"

    cat <<EOF >"${DESCRIPTION_PLIST}"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IFPkgDescriptionDescription</key>
	<string>${DESCRIPTION}</string>
	<key>IFPkgDescriptionTitle</key>
	<string>Amanda</string>
</dict>
</plist>
EOF
}

# make_package_info PKGINFO DESCRIPTION PREFIX
make_package_info() {
    local PKGINFO="${1}"
    local DESCRIPTION="${2}"
    local PREFIX="${3}"

    cat <<EOF >"${PKGINFO}"
Title Amanda
Version
Description ${DESCRIPTION}
DefaultLocation ${PREFIX}
DeleteWarning

### Package Flags

NeedsAuthorization YES
Required NO
Relocatable NO
RequiresReboot NO
UseUserMask NO
OverwritePermissions NO
InstallFat NO
RootVolumeOnly NO
OnlyUpdateInstalledLanguages NO
EOF
}

##
## Utility functions
##

errmsg() {
    echo "!! ${@}"
}

notemsg() {
    echo ">> ${@}"
}

BUILT_PKGS=
depend_on() {
    local pkg dep

    for dep in "${@}"; do
        found=false
        for pkg in ${BUILT_PKGS}; do
            if test x"$pkg" = x"$dep"; then
                found=true
                break
            fi
        done
        if ! $found; then
            errmsg "Dependency $dep has not been built yet."
            return 1
        fi
    done
    return 0
}

build_finished() {
    local pkg="${1}"
    BUILT_PKGS="${BUILT_PKGS} $pkg"
}

general_check() {
    local badpath
    local success=true

    if ! test -f configure.ac; then
        errmsg "This script must be run from the root of a distribution directory"
        return 1
    fi

    for badpath in "/opt/local" "/usr/local"; do
        if env | grep "${badpath}"; then
            errmsg "${badpath} appears in your environment (see above).  This could cause incorrect builds."
            success=false
        fi
    done

    if test -e "${PREFIX}"; then
        errmsg "${PREFIX} already exists.  This script completely rebuilds this directory, so please remove it before continuing."
        success=false
    fi

    $success
}

general_verify() {
    # post-install verification
    local unrecognized_libs=` \
        { find "$PREFIX" -name '*.dylib'; find "$PREFIX/bin" -type f; } \
        | xargs otool -L 2>/dev/null \
        | cut -c 2- | grep '^/' | cut -d' ' -f 1 \
        | grep -v ^"${PREFIX}" \
        | grep -v ^/System/Library \
        | grep -v ^/usr/lib \
        | sort -u`
    if test -n "${unrecognized_libs}"; then
        errmsg "The following unknown dynamic libraries are linked from within ${PREFIX}:"
        echo "${unrecognized_libs}"
        return 1
    fi

    return 0
}

##
## main
##

# set up the temporary build area
if test -d "${BUILD_TMP}"; then
    rm -rf "${BUILD_TMP}" || exit 1
fi

# make a general check
if ! general_check; then
    errmsg "Not ready to build.  Come back when you are ready."
    exit 1
fi


# check 'em all
success=true
for pkg in ${PACKAGES}; do
    if ! ( check_tarball ${pkg} ${pkg}_VERSION ${pkg}_URL ); then
        success=false
    fi
done
if ! $success; then
    errmsg "Checks failed; aborting build"
    exit 1
fi

# be sure to look in the new prefix directory before anywhere else for binaries
PATH="${PREFIX}/bin:/bin:/sbin:/usr/bin:/usr/sbin"

# build 'em all
for pkg in ${PACKAGES}; do
    if ! ( build_${pkg} ); then
        errmsg "Aborting build"
        exit 1
    fi
    build_finished ${pkg}
done

# perform a general verification
if ! general_verify; then
    errmsg "Verification failed."
    exit 1
fi

# here comes the part where we package it up
make_pkg || exit 1

rm -rf "${BUILD_TMP}"
